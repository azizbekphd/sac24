import{V,b as H,L as T,F as k,G as J,B as P,c as _,d as z,M as A,P as M,e as q,f as S,g as C,h as G,r as x,u as B,i as W,k as $,S as K,j as Q,l as X,m as Y}from"./index-62ce51f8.js";const Z=/^[og]\s*(.+)?/,ee=/^mtllib /,te=/^usemtl /,se=/^usemap /,D=/\s+/,O=new V,E=new V,N=new V,R=new V,j=new V,F=new H;function ne(){const y={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(s,e){if(this.object&&this.object.fromDeclaration===!1){this.object.name=s,this.object.fromDeclaration=e!==!1;return}const i=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:s||"",fromDeclaration:e!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(t,n){const l=this._finalize(!1);l&&(l.inherited||l.groupCount<=0)&&this.materials.splice(l.index,1);const h={index:this.materials.length,name:t||"",mtllib:Array.isArray(n)&&n.length>0?n[n.length-1]:"",smooth:l!==void 0?l.smooth:this.smooth,groupStart:l!==void 0?l.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(m){const o={index:typeof m=="number"?m:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return o.clone=this.clone.bind(o),o}};return this.materials.push(h),h},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(t){const n=this.currentMaterial();if(n&&n.groupEnd===-1&&(n.groupEnd=this.geometry.vertices.length/3,n.groupCount=n.groupEnd-n.groupStart,n.inherited=!1),t&&this.materials.length>1)for(let l=this.materials.length-1;l>=0;l--)this.materials[l].groupCount<=0&&this.materials.splice(l,1);return t&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),n}},i&&i.name&&typeof i.clone=="function"){const t=i.clone(0);t.inherited=!0,this.object.materials.push(t)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(s,e){const i=parseInt(s,10);return(i>=0?i-1:i+e/3)*3},parseNormalIndex:function(s,e){const i=parseInt(s,10);return(i>=0?i-1:i+e/3)*3},parseUVIndex:function(s,e){const i=parseInt(s,10);return(i>=0?i-1:i+e/2)*2},addVertex:function(s,e,i){const t=this.vertices,n=this.object.geometry.vertices;n.push(t[s+0],t[s+1],t[s+2]),n.push(t[e+0],t[e+1],t[e+2]),n.push(t[i+0],t[i+1],t[i+2])},addVertexPoint:function(s){const e=this.vertices;this.object.geometry.vertices.push(e[s+0],e[s+1],e[s+2])},addVertexLine:function(s){const e=this.vertices;this.object.geometry.vertices.push(e[s+0],e[s+1],e[s+2])},addNormal:function(s,e,i){const t=this.normals,n=this.object.geometry.normals;n.push(t[s+0],t[s+1],t[s+2]),n.push(t[e+0],t[e+1],t[e+2]),n.push(t[i+0],t[i+1],t[i+2])},addFaceNormal:function(s,e,i){const t=this.vertices,n=this.object.geometry.normals;O.fromArray(t,s),E.fromArray(t,e),N.fromArray(t,i),j.subVectors(N,E),R.subVectors(O,E),j.cross(R),j.normalize(),n.push(j.x,j.y,j.z),n.push(j.x,j.y,j.z),n.push(j.x,j.y,j.z)},addColor:function(s,e,i){const t=this.colors,n=this.object.geometry.colors;t[s]!==void 0&&n.push(t[s+0],t[s+1],t[s+2]),t[e]!==void 0&&n.push(t[e+0],t[e+1],t[e+2]),t[i]!==void 0&&n.push(t[i+0],t[i+1],t[i+2])},addUV:function(s,e,i){const t=this.uvs,n=this.object.geometry.uvs;n.push(t[s+0],t[s+1]),n.push(t[e+0],t[e+1]),n.push(t[i+0],t[i+1])},addDefaultUV:function(){const s=this.object.geometry.uvs;s.push(0,0),s.push(0,0),s.push(0,0)},addUVLine:function(s){const e=this.uvs;this.object.geometry.uvs.push(e[s+0],e[s+1])},addFace:function(s,e,i,t,n,l,h,m,o){const c=this.vertices.length;let r=this.parseVertexIndex(s,c),a=this.parseVertexIndex(e,c),u=this.parseVertexIndex(i,c);if(this.addVertex(r,a,u),this.addColor(r,a,u),h!==void 0&&h!==""){const p=this.normals.length;r=this.parseNormalIndex(h,p),a=this.parseNormalIndex(m,p),u=this.parseNormalIndex(o,p),this.addNormal(r,a,u)}else this.addFaceNormal(r,a,u);if(t!==void 0&&t!==""){const p=this.uvs.length;r=this.parseUVIndex(t,p),a=this.parseUVIndex(n,p),u=this.parseUVIndex(l,p),this.addUV(r,a,u),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(s){this.object.geometry.type="Points";const e=this.vertices.length;for(let i=0,t=s.length;i<t;i++){const n=this.parseVertexIndex(s[i],e);this.addVertexPoint(n),this.addColor(n)}},addLineGeometry:function(s,e){this.object.geometry.type="Line";const i=this.vertices.length,t=this.uvs.length;for(let n=0,l=s.length;n<l;n++)this.addVertexLine(this.parseVertexIndex(s[n],i));for(let n=0,l=e.length;n<l;n++)this.addUVLine(this.parseUVIndex(e[n],t))}};return y.startObject("",!1),y}class ie extends T{constructor(s){super(s),this.materials=null}load(s,e,i,t){const n=this,l=new k(this.manager);l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(s,function(h){try{e(n.parse(h))}catch(m){t?t(m):console.error(m),n.manager.itemError(s)}},i,t)}setMaterials(s){return this.materials=s,this}parse(s){const e=new ne;s.indexOf(`\r
`)!==-1&&(s=s.replace(/\r\n/g,`
`)),s.indexOf(`\\
`)!==-1&&(s=s.replace(/\\\n/g,""));const i=s.split(`
`);let t=[];for(let h=0,m=i.length;h<m;h++){const o=i[h].trimStart();if(o.length===0)continue;const c=o.charAt(0);if(c!=="#")if(c==="v"){const r=o.split(D);switch(r[0]){case"v":e.vertices.push(parseFloat(r[1]),parseFloat(r[2]),parseFloat(r[3])),r.length>=7?(F.setRGB(parseFloat(r[4]),parseFloat(r[5]),parseFloat(r[6])).convertSRGBToLinear(),e.colors.push(F.r,F.g,F.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(r[1]),parseFloat(r[2]),parseFloat(r[3]));break;case"vt":e.uvs.push(parseFloat(r[1]),parseFloat(r[2]));break}}else if(c==="f"){const a=o.slice(1).trim().split(D),u=[];for(let f=0,g=a.length;f<g;f++){const b=a[f];if(b.length>0){const v=b.split("/");u.push(v)}}const p=u[0];for(let f=1,g=u.length-1;f<g;f++){const b=u[f],v=u[f+1];e.addFace(p[0],b[0],v[0],p[1],b[1],v[1],p[2],b[2],v[2])}}else if(c==="l"){const r=o.substring(1).trim().split(" ");let a=[];const u=[];if(o.indexOf("/")===-1)a=r;else for(let p=0,f=r.length;p<f;p++){const g=r[p].split("/");g[0]!==""&&a.push(g[0]),g[1]!==""&&u.push(g[1])}e.addLineGeometry(a,u)}else if(c==="p"){const a=o.slice(1).trim().split(" ");e.addPointGeometry(a)}else if((t=Z.exec(o))!==null){const r=(" "+t[0].slice(1).trim()).slice(1);e.startObject(r)}else if(te.test(o))e.object.startMaterial(o.substring(7).trim(),e.materialLibraries);else if(ee.test(o))e.materialLibraries.push(o.substring(7).trim());else if(se.test(o))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(c==="s"){if(t=o.split(" "),t.length>1){const a=t[1].trim().toLowerCase();e.object.smooth=a!=="0"&&a!=="off"}else e.object.smooth=!0;const r=e.object.currentMaterial();r&&(r.smooth=e.object.smooth)}else{if(o==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+o+'"')}}e.finalize();const n=new J;if(n.materialLibraries=[].concat(e.materialLibraries),!(e.objects.length===1&&e.objects[0].geometry.vertices.length===0)===!0)for(let h=0,m=e.objects.length;h<m;h++){const o=e.objects[h],c=o.geometry,r=o.materials,a=c.type==="Line",u=c.type==="Points";let p=!1;if(c.vertices.length===0)continue;const f=new P;f.setAttribute("position",new _(c.vertices,3)),c.normals.length>0&&f.setAttribute("normal",new _(c.normals,3)),c.colors.length>0&&(p=!0,f.setAttribute("color",new _(c.colors,3))),c.hasUVIndices===!0&&f.setAttribute("uv",new _(c.uvs,2));const g=[];for(let v=0,I=r.length;v<I;v++){const L=r[v],U=L.name+"_"+L.smooth+"_"+p;let d=e.materials[U];if(this.materials!==null){if(d=this.materials.create(L.name),a&&d&&!(d instanceof z)){const w=new z;A.prototype.copy.call(w,d),w.color.copy(d.color),d=w}else if(u&&d&&!(d instanceof M)){const w=new M({size:10,sizeAttenuation:!1});A.prototype.copy.call(w,d),w.color.copy(d.color),w.map=d.map,d=w}}d===void 0&&(a?d=new z:u?d=new M({size:1,sizeAttenuation:!1}):d=new q,d.name=L.name,d.flatShading=!L.smooth,d.vertexColors=p,e.materials[U]=d),g.push(d)}let b;if(g.length>1){for(let v=0,I=r.length;v<I;v++){const L=r[v];f.addGroup(L.groupStart,L.groupCount,v)}a?b=new S(f,g):u?b=new C(f,g):b=new G(f,g)}else a?b=new S(f,g[0]):u?b=new C(f,g[0]):b=new G(f,g[0]);b.name=o.name,n.add(b)}else if(e.vertices.length>0){const h=new M({size:1,sizeAttenuation:!1}),m=new P;m.setAttribute("position",new _(e.vertices,3)),e.colors.length>0&&e.colors[0]!==void 0&&(m.setAttribute("color",new _(e.colors,3)),h.vertexColors=!0);const o=new C(m,h);n.add(o)}return n}}const re={glb:Y,obj:ie},ae=({source:y,position:s,scale:e=1,color:i,rotation:t=[0,0,0]})=>{const n=x.useRef(null),l=x.useMemo(()=>{var a;return(a=y.split(".").pop())==null?void 0:a.toLowerCase()},[y]),h=x.useMemo(()=>{const a=re[l];if(!a)throw new Error(`Unsupported file extension: ${l}`);return a},[l]),m=B(h,y),o=x.useMemo(()=>m.scene?m.scene:m,[m]);x.useEffect(()=>()=>{W(o),B.clear(h,y)},[o,h,y]);const c=x.useMemo(()=>{if(!o)return;const a=new $().setFromObject(o.scene??o),u=new V;return a.getSize(u),K/u.y},[o]),r=x.useMemo(()=>e*X.camera.scale*c,[e,c]);return x.useEffect(()=>{n.current&&n.current.rotation.set(...t)},[t]),x.useEffect(()=>{n.current&&n.current.position.copy(s)},[s]),x.useEffect(()=>{n.current&&n.current.scale.set(r,r,r)},[r]),x.useLayoutEffect(()=>{!o||!i||!o.traverse||o.traverse(a=>{a.isMesh&&a.material.color.set(i)})},[i,o]),Q.jsx("primitive",{ref:n,object:o})};export{ae as default};
